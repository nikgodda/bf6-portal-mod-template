# BF6 Portal Mod Template

This is the official starter template for creating Battlefield 6 Portal Mods using TypeScript.

It provides:

-   clean project structure
-   ready main.ts and base AGameMode class
-   SDK typings (SDK/mod and SDK/modlib)
-   automatic merging into \_\_SCRIPT.ts
-   automatic string generation into \_\_STRINGS.json
-   integration with the bf6-portal-mod-framework build system

Use this template to build any structured BF6 Portal mod using classes, folders, and TypeScript modules â€” the framework turns it into one final script.

---

# ğŸ§± Project Structure

my-mod/
â”‚ package.json
â”‚ tsconfig.json
â”‚ **SCRIPT.ts â† generated by build
â”‚ **STRINGS.json â† generated by build
â”‚
â”œâ”€ SDK/
â”‚ â”œâ”€ mod/ â† official Battlefield Portal typings
â”‚ â””â”€ modlib/
â”‚
â””â”€ src/
â”œâ”€ main.ts â† entry point (creates game mode)
â”œâ”€ Core/
â”‚ â””â”€ AGameMode.ts
â””â”€ GameModes/
(your modes here)

All your gameplay code lives in src/.  
The framework flattens everything into \_\_SCRIPT.ts.

---

# ğŸš€ Installation

npm install

This installs:

-   TypeScript
-   bf6-portal-mod-framework (build system)

---

# âš™ Available Commands

### Build (merge + strings)

npm run build

Produces:

**SCRIPT.ts  
**STRINGS.json

Paste **SCRIPT.ts into the Portal Web Editor.  
Upload **STRINGS.json into the Portal UI String Editor.

---

### Watch (merge only)

npm run watch

Regenerates \_\_SCRIPT.ts whenever you save files.

âš  \_\_STRINGS.json is not updated in watch mode.  
Run npm run build when you modify string annotations.

---

### Update SDK

npm run update-sdk

Downloads the latest Portal SDK typings into SDK/.

---

# ğŸ® How Your Mod Runs

src/main.ts is executed first.  
You instantiate your game mode there:

import { MyGameMode } from './GameModes/MyGameMode'

export const gameMode = new MyGameMode()

Everything else is normal TypeScript â€” classes, interfaces, modules, nested files â€” the framework will merge it into one script.

---

# ğŸ’¬ Strings System (via bf6-portal-mod-framework)

The template supports static keys, dynamic template literals, and annotation-based dynamic values.  
The final output is written to:

\_\_STRINGS.json

---

# 1ï¸âƒ£ Static Strings

### Static Message

mod.Message('hello')

â†’ "hello": "hello"

### With Parameters

mod.Message('static.messageWithParams', 1)

â†’ "static.messageWithParams": "static.messageWithParams {}"

### Static StringKey

mod.stringkeys.static.stringkey

â†’ "static.stringkey": "static.stringkey"

Static keys always generate entries automatically.

---

# 2ï¸âƒ£ Dynamic Strings (Important)

Dynamic keys use template literals:

mod.Message(`ai.bots.${i}`)

BUT:

### âœ” Dynamic calls DO NOT generate dynamic keys

### âœ” Only annotations generate dynamic keys

### âœ” Dynamic calls only mark a namespace as "used" for warning mode

This is the correct behavior of the framework.

Example:

// @stringkeys ai.bots: 0..3
mod.Message(`ai.bots.${i}`)

Generated keys:

ai.bots.0  
ai.bots.1  
ai.bots.2  
ai.bots.3

These come **from the annotation only**, not from the loop or the dynamic call.

Dynamic calls without annotations are ignored entirely.

Supports both single-line and multi-line template literals.

---

# 3ï¸âƒ£ Annotations â€” @stringkeys

Format:

// @stringkeys <namespace>: <values>

Supported:

-   numeric ranges (0..3)
-   alphabet ranges (A..F)
-   lists (Idle, Roam, Fight)
-   mixed (Idle, A..C, 10..12)

Annotations ALWAYS generate their keys.

Example:

// @stringkeys ui.buttons: OK, Cancel, Retry

Creates:

ui.buttons.OK  
ui.buttons.Cancel  
ui.buttons.Retry

---

# ğŸ”¥ Full Real Example from Template

### Code:

mod.Message(`test`)

mod.Message(`static.message`)
mod.Message(`static.messageWithParams`, 1)

mod.stringkeys.static.stringkey

// @stringkeys dynamic.range: 1..2
for (let i = 0; i < 4; i++) {
mod.Message(`dynamic.range.${i}`)
}

// @stringkeys dynamic.list: Idle, Roam, Fight
const state = 'Idle'
mod.Message(`dynamic.list.${state}`)

### Generated Output (\_\_STRINGS.json):

{
"dynamic": {
"range": {
"1": "dynamic.range.1",
"2": "dynamic.range.2"
},
"list": {
"Idle": "dynamic.list.Idle",
"Roam": "dynamic.list.Roam",
"Fight": "dynamic.list.Fight"
}
},
"test": "test",
"static": {
"message": "static.message",
"messageWithParams": "static.messageWithParams {}",
"stringkey": "static.stringkey"
}
}

Notes:

-   Only annotation values are included (1 and 2)
-   Loop values 0 and 3 are ignored
-   Lists expand exactly as written
-   Static keys always generate entries

---

# 4ï¸âƒ£ Dynamic Key Rules

Dynamic keys must follow:

namespace.part.${variable}

### Valid:

mod.Message(`dynamic.range.${i}`)  
mod.Message(`ui.buttons.${btn}`)

### Invalid (ignored):

mod.Message(`ai.${type}.${i}`)  
mod.Message(`${a}.${b}`)  
mod.Message(`bots.${p}.${x}`)

Only one trailing dynamic segment is supported.

---

# âš  Optional: Warn About Removed Keys

Add to package.json:

{
"bf6mod": {
"warnUnusedStrings": true
}
}

Dynamic calls mark namespaces as used, preventing false unused warnings.

---

# ğŸ§© Recommended Mod Layout

Any folder structure is supported:

src/
Core/
GameModes/
AI/
Utils/
Weapons/
UI/

The framework merges all of it into one script.

---

# ğŸª„ Build Output

After:

npm run build

You get:

**SCRIPT.ts â†’ paste into Portal Web Editor  
**STRINGS.json â†’ upload to Portal UI

---

# ğŸ“œ License

MIT
